\chapter{Implementation: Quantum Systems}

For a quantum system to be studied on the computer it is necessary to 
make a distinction for what defines the system. One must therefore undergo the
mathematical procedure of defining a finite basis sets that defines the 
quantum system under scrutiny when dealing with the electronic problem. 

Here we present the \lstinline{quantum_system} python module, designed to 
provide basis sets for one- and two-dimensional quantum dots. The two-dimensional 
quantum dot can also be modelled with a constant, homogeneous magnetic field; and 
as a double quantum dot. 
Moreover, the module includes an option for constructing a custom system which can 
be interfaced with popular quantum chemistry packages \lstinline{PySCF}\cite{PYSCF} 
and \lstinline{Psi4}\cite{parrish2017psi4}.

The \lstinline{quantum_system} module can installed from github with \lstinline{pip}
by the following command,
\begin{lstlisting}[language=bash]
pip install git+https://github.com/Schoyen/quantum-systems.git
\end{lstlisting}
The same task can of course be accomplished by more commands,
\begin{lstlisting}[language=bash]
git clone https://github.com/Schoyen/quantum-systems.git
cd quantum-systems
pip install .
\end{lstlisting}

\noindent
--------------\\
NOTE: not sure the part below here is necessary. Maybe just link to web page 
documentation? If it is done, that is.. \\
--------------

It can be useful to install the module to a separate environment. We have made this 
possible through \lstinline{conda},
\begin{lstlisting}[language=bash]
conda environment create -f environment.yml
conda activate quantum-systems    
\end{lstlisting}

\section{Quantum Dots}

In reality, quantum dots are nanometre-sized structures made of semiconductor materials.
Theoretically, quantum dots are easy to model by harmonic oscillator potential and in practice
they are relativelty easy to manufacture in a laboratory. This doubly
theoretical-experimental benefit has made quantum dots a popular area of study. Moreover so 
because of their wide area of apllications.

The possible applications of quantum dots are many. Coupled single-electron quantum dots 
could potentially be used as harware elements in quantum computers, i.e.
qubits\cite{loss1998quantum}; quantum dots also promise to increase the efficiency of 
photvoltaic solar cells; and they have already found use in cellular imaging in biology.
Reimann and Manninen\cite{reimann2002electronic} has written an outstandingly
thorough review on quantum dots, covering their varied types of fabrication, theoretical
methods common in their study and vast ocean of applications.

The usefulness and relative theoretical ease of modelling warrants the study of quantum dots.
Herein, several classes have been implemented in order to construct basis sets modelling 
quantum dots in both one and two dimensions. These basis sets models \emph{bound} systems
as the common harmonic oscillator-type potentials that are used have the characteristics of 
infinite quantum wells. 

\subsection{One Dimension}

This is perhaps one of the simplest of all quantum mechanical 
models, being studied ad nauseum in everyones introductory quantum 
mechanics course. The one-body part of the Hamiltonian for the one-dimensional quantum 
harmonic oscillator is,
\begin{equation}
    \label{eq:1d_ho_hamiltonian}
    \hat{h} = \frac{\hat{p}^2}{2m} + \frac{1}{2}m \omega^2\hat{x}^2.
\end{equation}
The potential, $\hat{v} = \frac{1}{2}m \omega^2\hat{x}^2$, forms the well known 
parabolig curve. In a general one-dimensional system, this potenation could 
readily be exchanged for something else. For instance that of the 
\emph{double well},
\begin{equation}
    \hat{v} = \frac{1}{2} m \omega^2
        \left(\hat{x}^2 + \frac{1}{4}l^2 - l |\hat{x}|\right),
\end{equation}
where $l$ is the width of a barrier in the middle of the parabolic 
potential.

In atomic units we can set $\hbar = m = 1$. Substituting for the 
momentum operator, $\hat{p} = \hat{-i\hbar (\partial / \partial x)}$, gives us 
\begin{equation}
    \label{eq:1d_hamiltonian}
    \hat{h} = - \frac{1}{2} \frac{\partial^2}{\partial x^2} + \hat{v}.
\end{equation}
The second-order derivate can be approximated by the central difference 
formula for some function $f(x)$, yielding
\begin{equation}
    f''(x) = \frac{f(x + dx) - 2f(x) +f(x - dx)}{dx^2},
\end{equation}
for some small $dx$. This means that we approximate the Hamilton 
operator of the system (\autoref{eq:1d_hamiltonian}) by a matrix,
\begin{equation}
    h^p_q =  \begin{pmatrix}
    1/dx^2 + v_1 & -1/2dx^2 & \ddots & & & \\
    -1/2dx^2 & 1/dx^2 + v_2 & -1/2dx^2 & \ddots & & \\
    \ddots & -1/2dx^2 & 1/dx^2 + v_3 & -1/2dx^2 & \ddots & \\
    & \ddots & \ddots & \ddots & \ddots & \ddots \\
    & & \ddots & -1/2dx^2 & 1/dx^2 + v_{n-1} & -1/2dx^2 \\
    & & & \ddots & -1/2dx^2 & 1/dx^2 + v_n
    \end{pmatrix},
\end{equation}
and we have thus transformed the time-independent Schr√∂dinger equation
\begin{equation}
    \hat{h} \ket{n} = \epsilon \ket{n},
\end{equation}
into a matrix equation which is easily representable and solvable on a computer, where $n$ is 
the number of points used to numerically represent the wavefunciton 
and Hamiltonian mateix representation. This is done with some generic 
eigenvalue solver, for instance \lstinline{numpy.linalg.eigh}.
The eigen functions provide the foundations for the single-particle functions.

Since we would like to model interaction between particles we need something more,
than just a numerical representation of the one-body operator. We therefore need to 
compute coulomb interaction, in the form of an integral. This is done in
several steps, starting with an ``inner intergral'' over all all space 
and two and two single-particle functions,
\begin{equation}
   u^q_s = \int \phi_q(x_1) \frac{\alpha}{(x_1-x_2)^2 + 2a^2}  \phi_s(x_2) dx,
\end{equation}
where $a$ and $\alpha$ are parameters that are necessary to include for this integral 
to be calculable.
Numerically, this part is divided into two functions in our python implementation,
\begin{python}
def _shielded_coulomb(x_1, x_2, alpha, a):
    return alpha / np.sqrt((x_1 - x_2) ** + a ** 2)

def _compute_inner_integral(spf, l, num_grid_points, grid, alpha, a):
    inner_integral = np.zeros((l, l, num_grid_points), dtype=np.complex128)

    for q in range(l):
        for s in range(l):
            for i in range(num_grid_points):
                inner_integral[q, s, i] = _trapz(
                    spf[q]
                    * _shielded_coulomb(grid[i], grid, alpha, a)
                    * spf[s],
                    grid,
                )

    return inner_integral
\end{python}
The inner orbital is then used in the computation in the orbial integral,
\begin{equation}
    w^{pq}_{rs} = \int \phi_p u^q_s \phi_r dx,
\end{equation}
which numerically is implemented as follows,
\begin{python}
def _compute_orbital_integrals(spf, l, inner_integral, grid):
    u = np.zeros((l, l, l, l), dtype=np.complex128)

    for p in range(l):
        for q in range(l):
            for r in range(l):
                for s in range(l):
                    u[p, q, r, s] = _trapz(
                        spf[p] * inner_integral[q, s] * spf[r], grid
                    )

    return u
\end{python}

Each integral is solved by the trapezoidal scheme,
\begin{python}
def _trapz(f, x):
   n = len(x)
   delta_x = x[1] - x[0]
   val = 0

   for i in range(1, n):
       val += f[i - 1] + f[i]

   return 0.5 * val * delta_
  
\end{python}

Needless to say, computing the coulomb integrals is one of the more compute-heave tasks,
and we therefore make great use of just-in-time compulation from the \lstinline{numba} 
module for python.

A full representation of the one-dimensional quantum dot (oscillator) class i provided 
below,
\input{implementation/doc/one_dim_quantom_dot.tex}

\subsection{Two Dimensions}

\subsubsection{Double well}

\subsubsection{Magnetic field}

\section{Constructing a Custom System}

\section{Time Evolution}

