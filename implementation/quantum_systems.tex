\chapter{Implementation: Quantum Systems}

For a quantum system to be studied on the computer it is necessary to 
make a distinction for what defines the system. One must therefore undergo the
mathematical procedure of defining a finite basis sets that defines the 
quantum system under scrutiny when dealing with the electronic problem. 

Here we present the \lstinline{quantum_system} python module, designed to 
provide basis sets for one- and two-dimensional quantum dots. The two-dimensional 
quantum dot can also be modelled with a constant, homogeneous magnetic field; and 
as a double quantum dot. 
Moreover, the module includes an option for constructing a custom system which can 
be interfaced with popular quantum chemistry packages \lstinline{PySCF}\cite{PYSCF} 
and \lstinline{Psi4}\cite{parrish2017psi4}.

The \lstinline{quantum_system} module can installed from github with \lstinline{pip}
by the following command,
\begin{lstlisting}[language=bash]
pip install git+https://github.com/Schoyen/quantum-systems.git
\end{lstlisting}
The same task can of course be accomplished by more commands,
\begin{lstlisting}[language=bash]
git clone https://github.com/Schoyen/quantum-systems.git
cd quantum-systems
pip install .
\end{lstlisting}

\noindent
--------------\\
NOTE: not sure the part below here is necessary. Maybe just link to web page 
documentation? If it is done, that is.. \\
--------------

It can be useful to install the module to a separate environment. We have made this 
possible through \lstinline{conda},
\begin{lstlisting}[language=bash]
conda environment create -f environment.yml
conda activate quantum-systems    
\end{lstlisting}

\section{Quantum Dots}

In reality, quantum dots are nanometre-sized structures made of semiconductor materials.
Theoretically, quantum dots are easy to model by harmonic oscillator potential and in practice
they are relativelty easy to manufacture in a laboratory. This doubly
theoretical-experimental benefit has made quantum dots a popular area of study. Moreover so 
because of their wide area of apllications.

The possible applications of quantum dots are many. Coupled single-electron quantum dots 
could potentially be used as harware elements in quantum computers, i.e.
qubits\cite{loss1998quantum}; quantum dots also promise to increase the efficiency of 
photvoltaic solar cells; and they have already found use in cellular imaging in biology.
Reimann and Manninen\cite{reimann2002electronic} has written an outstandingly
thorough review on quantum dots, covering their varied types of fabrication, theoretical
methods common in their study and vast ocean of applications.

The usefulness and relative theoretical ease of modelling warrants the study of quantum dots.
Herein, several classes have been implemented in order to construct basis sets modelling 
quantum dots in both one and two dimensions. These basis sets models \emph{bound} systems
as the common harmonic oscillator-type potentials that are used have the characteristics of 
infinite quantum wells. 

\subsection{One Dimension}

This is perhaps one of the simplest of all quantum mechanical 
models, being studied ad nauseum in everyones introductory quantum 
mechanics course. The one-body part of the Hamiltonian for the one-dimensional quantum 
harmonic oscillator is,
\begin{equation}
    \label{eq:1d_ho_hamiltonian}
    \hat{h} = \frac{\hat{p}^2}{2m} + \frac{1}{2}m \omega^2\hat{x}^2.
\end{equation}
The potential, $\hat{v} = \frac{1}{2}m \omega^2\hat{x}^2$, forms the well known 
parabolig curve. In a general one-dimensional system, this potenation could 
readily be exchanged for something else. For instance that of the 
\emph{double well},
\begin{equation}
    \hat{v} = \frac{1}{2} m \omega^2
        \left(\hat{x}^2 + \frac{1}{4}l^2 - l |\hat{x}|\right),
\end{equation}
where $l$ is the width of a barrier in the middle of the parabolic 
potential.

In atomic units we can set $\hbar = m = 1$. Substituting for the 
momentum operator, $\hat{p} = \hat{-i\hbar (\partial / \partial x)}$, gives us 
\begin{equation}
    \label{eq:1d_hamiltonian}
    \hat{h} = - \frac{1}{2} \frac{\partial^2}{\partial x^2} + \hat{v}.
\end{equation}
The second-order derivate can be approximated by the central difference 
formula for some function $f(x)$, yielding
\begin{equation}
    f''(x) = \frac{f(x + dx) - 2f(x) +f(x - dx)}{dx^2},
\end{equation}
for some small $dx$. This means that we approximate the Hamilton 
operator of the system (\autoref{eq:1d_hamiltonian}) by a matrix,
\begin{equation}
    h^p_q =  \begin{pmatrix}
    1/dx^2 + v_1 & -1/2dx^2 & \ddots & & & \\
    -1/2dx^2 & 1/dx^2 + v_2 & -1/2dx^2 & \ddots & & \\
    \ddots & -1/2dx^2 & 1/dx^2 + v_3 & -1/2dx^2 & \ddots & \\
    & \ddots & \ddots & \ddots & \ddots & \ddots \\
    & & \ddots & -1/2dx^2 & 1/dx^2 + v_{n-1} & -1/2dx^2 \\
    & & & \ddots & -1/2dx^2 & 1/dx^2 + v_n
    \end{pmatrix},
\end{equation}
and we have thus transformed the time-independent Schr√∂dinger equation
\begin{equation}
    \hat{h} \ket{n} = \epsilon \ket{n},
\end{equation}
into a matrix equation which is easily representable and solvable on a computer, where $n$ is 
the number of points used to numerically represent the wavefunciton 
and Hamiltonian mateix representation. This is done with some generic 
eigenvalue solver, for instance \lstinline{numpy.linalg.eigh}.
The eigen functions provide the foundations for the single-particle functions.

Since we would like to model interaction between particles we need something more,
than just a numerical representation of the one-body operator. We therefore need to 
compute coulomb interaction, in the form of an integral. This is done in
several steps, starting with an ``inner intergral'' over all all space 
and two and two single-particle functions,
\begin{equation}
   u^q_s = \int \phi_q(x_1) \frac{\alpha}{(x_1-x_2)^2 + 2a^2}  \phi_s(x_2) dx,
\end{equation}
where $a$ and $\alpha$ are parameters that are necessary to include for this integral 
to be calculable.
Numerically, this part is divided into two functions in our python implementation,
\begin{python}
def _shielded_coulomb(x_1, x_2, alpha, a):
    return alpha / np.sqrt((x_1 - x_2) ** + a ** 2)

def _compute_inner_integral(spf, l, num_grid_points, grid, alpha, a):
    inner_integral = np.zeros((l, l, num_grid_points), dtype=np.complex128)

    for q in range(l):
        for s in range(l):
            for i in range(num_grid_points):
                inner_integral[q, s, i] = _trapz(
                    spf[q]
                    * _shielded_coulomb(grid[i], grid, alpha, a)
                    * spf[s],
                    grid,
                )

    return inner_integral
\end{python}
The inner orbital is then used in the computation in the orbial integral,
\begin{equation}
    w^{pq}_{rs} = \int \phi_p u^q_s \phi_r dx,
\end{equation}
which numerically is implemented as follows,
\begin{python}
def _compute_orbital_integrals(spf, l, inner_integral, grid):
    u = np.zeros((l, l, l, l), dtype=np.complex128)

    for p in range(l):
        for q in range(l):
            for r in range(l):
                for s in range(l):
                    u[p, q, r, s] = _trapz(
                        spf[p] * inner_integral[q, s] * spf[r], grid
                    )

    return u
\end{python}

Each integral is solved by the trapezoidal scheme,
\begin{python}
def _trapz(f, x):
   n = len(x)
   delta_x = x[1] - x[0]
   val = 0

   for i in range(1, n):
       val += f[i - 1] + f[i]

   return 0.5 * val * delta_
  
\end{python}

Needless to say, computing the coulomb integrals is one of the more compute-heave tasks,
and we therefore make great use of just-in-time compulation from the \lstinline{numba} 
module for python.

A full representation of the one-dimensional quantum dot (oscillator) class is provided 
below,
\input{implementation/doc/one_dim_quantum_dot.tex}

\subsection{Two Dimensions}

The one-body part of the Hamiltonian for a two-dimensional quantum dots is almost
identical to the one-body part for a one-dimensional quantum dot. In cartesian
coordinates we simple include a $y$ in the potential as well as an $x$, but mostly 
because we have analytical expressions for the Coulomb integrals in polar
coordinates\cite{anisimovas1998energy}, we write the one-body operators in 
polar coordinates as well with $\hat{r}^2 = \hat{x}^2 + \hat{y}^2$,
\begin{equation}
    \hat{h} = \frac{\hat{p}^2}{2m} + \frac{1}{2}m\omega^2\hat{r}^2
        = - \frac{\hbar^2}{2m}\left(
            \frac{\partial^2}{\partial r^2}
            + \frac{1}{r} \frac{\partial}{\partial r}
            + \frac{1}{r^2} \frac{\partial^2}{\partial \theta^2}
        \right)
        + \frac{1}{2}m\omega^2\hat{r}^2.
\end{equation}

The wavefunctions for a two-dimensional harmonic oscillator can be
written
\begin{equation}
    \label{eq:2d_ho_eigenstate}
    \phi(r,\theta) = N_{nm} (ar)^{\abs{m}} L_n^{\abs{m}}(a^2r^2)
        e^{-a^2r^2/2} e^{im\theta},
\end{equation}
where $a=\sqrt{m\omega/\hbar}$ si the Bohr radius, $L^{\abs{m}}_n$ is 
the associated Laguerre polynomials, $n$ and $m$ are the principal and
the azimutal quantum numbers respectively, and $N_{nm}$ is a normalisation 
factor given by,
\begin{equation}
    N_{nm} = a\sqrt{\frac{n!}{\pi(n + \abs{m})!}}.
\end{equation}

The energy eigenvalues of a two-dimensional harmonic oscillator is given by 
\begin{equation}
    \epsilon_{nm} = \hbar\omega(2n + \abs{m} + 1).
\end{equation}
An important difference between the one-dimensional quantum dot and a two-dimensional 
quantum dot is that in the latter we have energy degeneracies of the eigenstates.
This is illustrated in \autoref{fig:2d_basis_states}. In this figure we have included 
a spin-up and a spin-down state for each $n,m$-state. This spin feature is not in any way 
included in \autoref{eq:2d_ho_eigenstate}, but we may represent the spin condition by
including it in the orthonormality conditions of the wavefunctions,
\begin{equation}
    \braket{n_1m_1\sigma_1}{n_2m_2\sigma_2} 
    = \delta_{n_1n_2}\delta_{m_1m_2}\delta_{\sigma_1\sigma_2},
\end{equation}
where $\sigma$ is the spin.

\begin{figure}
    \begin{center}
        \begin{tikzpicture}[scale=0.8]
            \begin{scope}
                \foreach \i in {1, 2, 3} {
                    \draw(-1, \i - 1) node[anchor=east]
                    {$\epsilon = \i$};
                }

                % Highest energy level
                \foreach \i in {0, 3, 6} {
                    \draw (\i, 2) -- (\i + 2, 2);
                    \node at (\i + 0.75, 2) {$\uparrow$};
                    \node at (\i + 1.25, 2) {$\downarrow$};
                }
                \node[below, inner sep=.2cm] at (1, 2)
                {$n = 0, m = -2$};
                \node[below, inner sep=.2cm] at (4, 2)
                {$n = 1, m = 0$};
                \node[below, inner sep=.2cm] at (7, 2)
                {$n = 0, m = 2$};

                % Middle energy level
                \foreach \i in {1.5, 4.5} {
                    \draw (\i, 1) -- (\i + 2, 1);
                    \node at (\i + 0.75, 1) {$\uparrow$};
                    \node at (\i + 1.25, 1) {$\downarrow$};
                }
                \node[below, inner sep=.2cm] at (2.5, 1)
                {$n = 0, m = -1$};
                \node[below, inner sep=.2cm] at (5.5, 1)
                {$n = 0, m = 1$};

                % Lowest energy level
                \draw (3, 0) -- (5, 0);
                \node at (3 + 0.75, 0) {$\uparrow$};
                \node at (3 + 1.25, 0) {$\downarrow$};
                \node[below, inner sep=.2cm] at (4, 0)
                {$n = 0, m = 0$};
            \end{scope}
        \end{tikzpicture}
    \end{center}
    \caption{In this plot we see the energy degeneracy of the
    lowest three energy levels in the two-dimensional quantum dot.
    Each arrow representes a spin up or a spin down state with the
    quantum numbers $n$ and $m$ as listed below. This pattern goes
    on indefinitly with the addition of one bar (two oscillators)
    per level.}
    \label{fig:2d_basis_states}
\end{figure}

Because of the energy degeneracy present in two-dimensional quantum dots,
it is necessary to make a mapping from the three quantum numbers $n$, $m$,
to a single (quantum) number $p$. This functionality $(n,m)\mapsto p$ is 
achieved by the following python function
\begin{python}
def get_index_p(n, m):
    num_shells = 2 * n + abs(m) + 1

    previous_shell = 0
    for i in range(1, num_shells):
        previous_shell += i

    current_shell = previous_shell + num_shells

    if m == 0:
        if n == 0:
            return 0

        p = previous_shell + (current_shell - previous_shell) // 2

        return p

    elif m < 0:
        return previous_shell + n

    else:
        return current_shell - (n + 1)
\end{python}
It will also be necessary to map back $p\mapsto(n,m)$,
\begin{python}
def get_indices_nm(p):
    n, m = 0, 0
    previous_shell = 0
    current_shell = 1
    shell_counter = 1

    while current_shell <= p:
        shell_counter += 1
        previous_shell = current_shell
        current_shell = previous_shell + shell_counter

    middle = (current_shell - previous_shell) / 2 + previous_shell

    if (current_shell - previous_shell) & 0x1 == 1 and abs(
        p - math.floor(middle)
    ) < 1e-8:
        n = shell_counter // 2
        m = 0

        return n, m

    if p < middle:
        n = p - previous_shell
        m = -((shell_counter - 1) - 2 * n)

    else:
        n = (current_shell - 1) - p
        m = (shell_counter - 1) - 2 * n

    return n, m
\end{python}

\input{implementation/doc/two_dim_quantum_dot.tex}

\subsubsection{Double well}

\input{implementation/doc/two_dim_double_dot.tex}

\subsubsection{Magnetic field}

\section{Constructing a Custom System}

\section{Time Evolution}

