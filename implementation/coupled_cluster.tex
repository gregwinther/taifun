\chapter{Implementation: Coupled Cluster}

The main product of this study is manifested in the \lstinline{coupled_cluster}
module for Python. This module is designed to fit together with the
\lstinline{quantum_systems} module described in the previous chapter. We have tried to 
make this module easy to extend, resulting in a framework where every solver scheme 
inherits from an abstract parent class that specifies what must be implemented in order 
to make a supplemental solver or class operational in conjunction with the rest of the 
framework.

As a beginning to this project, which we hope will continue to grow and be used, 
we have implemented several different ground state solver classes, and several
time-dependent solver classes. In order of increasing sophistication and 
elegance, we have a ground state- and a time-dependent solver for both the coupled cluster
method
with double excitations (CCD), the coupled cluster method with singles- and double 
excitations (CCSD), and for the orbital-adaptive coupled cluster method with double
excitations (OACCD). The time-dependent solvers within a particular categor are 
dependent on its ground state counterpart, but the ground state solvers can be used
independently.

The \lstinline{coupled_cluster} module can be install from github via \lstinline{pip}
by the following command,
\begin{lstlisting}[language=bash]
pip install git+https://github.com/Schoyen/coupled-cluster.git
\end{lstlisting}
If one prefers, the same task can be accomplished by the following commands,
\begin{lstlisting}[language=bash]
git clone https://github.com/Schoyen/coupled-cluster.git
cd coupled-cluster
pip install .
\end{lstlisting}
We have supplied environment specifications for \lstinline{conda}, with requirement 
specifications for the convenience of the user. Assuming the git repository is cloned 
properly,
\begin{lstlisting}[language=bash]
conda environment create -f environment.yml
\end{lstlisting}
Activate the environment with,
\begin{lstlisting}[language=bash]
conda activate cc
\end{lstlisting}
In the future, we hope that full documentation can be found on
\url{www.coupled-cluster.com}.

\section{[UNFINISHED] Ground State Computations}

    All ground state solver within the \lstinline{coupled_cluster} module are built 
    as sub-classes of the abstract base class \lstinline{CoupledCluter}. The most
    important method of this class is the \lstinline{compute_ground_state()} method.
    This method in turn calls the \lstinline{iterate_t_amplitudes()} and 
    \lstinline{iterate_l_amplitudes()} successively. 

    \input{implementation/doc/coupled_cluster.tex}

    As we have outlined in 
    \autoref{ch:coupled_cluster_theory}, the $\tau$ amplitudes are only dependent on 
    $\tau$, while the $\lambda$ amplitudes are dependent on both $\tau$ and $\lambda$.
    Therefore, the $\tau$ amplitude equation iterative solver
    \lstinline{iterate_t_amplitudes()} is called first, and the $\lambda$ amplitude
    equation solver is called second.
    The most important section of the \lstinline{compute_l_amplitudes()} method 
    is the following
    \begin{python}
    for i in range(max_iterations):
    self.compute_l_amplitudes()
    residuals = self.compute_l_residuals()

    if self.verbose:
        print(f"Iteration: {i}\tResiduals (l): {residuals}")

    if all(res < tol for res in residuals):
        break

    assert i < (
        max_iterations - 1
    ), f"The l amplitudes did not converge. Last residual: {residuals}" 
    \end{python}
    The equivalent section in the \lstinline{compute_t_amplitudes()} method is nearly
    identical.
    The \lstinline{CoupledCluster} class is supposed to provide a framework for which 
    to implement various coupled cluster ground state solver classes. It therefore
    has several abstract classes that such subclasses need to implement and overwrite.
    The most important of these are the methods \lstinline{compute_t_amplitudes} 
    and \lstinline{compute_l_amplitudes}, which are supposed to contain the evaluation 
    of amplitude equations for a given coupled cluster truncation and scheme. 

    With the hope that the functunality of the rest of the methods can be inferred from 
    name, and with the goal of brevity we proceed to a study of the simplest 
    ground state coupled cluster solver, namely CCD, implemented in the 
    \lstinline{CoupledClusterDoubles} class.
   
    Starting from construction, the \lstinline{CoupledClusterDoubles} class passes 
    the system, defined through a \lstinline{QuantumSystem} object to the 
    parent class constructor, along with any keyword arguments, such as turning 
    on verbosity, mixer type to us and what matrix library to apply. The
    \lstinline{QuantumSystem} class will contain all the information necessary to 
    set up the system, i.e. construct a one-body matrix, fock matrix and two-body 
    matrix. These will be used to set up empty arrays for the $\tau$ and $\lambda$ 
    amplitudes. The \lstinline{comput_initial_guess} is called lastly in the 
    constructor, computing the inital guess of the double-excited amplitudes as 
    \begin{equation}
        \label{eq:ccd_inital_guess}
        \tau^{(0)} = \frac{u^{ab}_{ij}}{D^{ab}_{ij}},
    \end{equation}
    where $u$ is the two-body operator and
    $D^{ab}_{ij} = f^a_a + f^b_b - f^i_i - f^j_j$,
    where $f$ is the Fock operator.
    
    In the \lstinline{CoupledClusterDobles} class specification one would
    notice that it has implementations of all the abstract methods 
    from the \lstinline{CoupledCluster} abstract class. The reason for the existence 
    of the class, the \lstinline{compute_ground_state()} method, is inherited from the 
    parent class, and does the same thing as described above - calling 
    \lstinline{iterate_t_amplitudes()} and \lstinline{iterate_l_amplitudes()}. These 
    methods alos excist as members of \lstinline{CoupledClusterDoubles}, but are excluded 
    from the class specification for sake of brevity. It is 
    possible to pass arguments to the the two iterator methods; one list for each iteration
    method, or as keywords.
    One can also pass arguments 
    to the mixer through the \lstinline{compute_ground_state_method()}. 
    An overview of mixing applied to iterative solvers is given in the next 
    section.

    The important part of the specific coupled cluster scheme solver is contained in the two 
    methods \lstinline{compute_t_amplitudes()} and \lstinline{compute_l_amplitudes()}.
    These functions evaluate the entire coupled cluster doubles amplitude equations.
    The computation of each term (diagram) in the amplitude equation is done in separate functions,
    as calls to \lstinline{numpy.tensordot()}, for a total of ten terms for the 
    $\tau$ amplitude equation in the coupled cluster doubles method including 
    permutation operators:
    \begin{equation}
        \label{eq:ccd_tau}
        \begin{aligned}
        0 =& u^{ab}_{ij} + f^b_c \tau^{ac}_{ij}P(ab) 
            - f^k_j \tau^{ab}_{ik}P(ij)
            + \frac{1}{4} \tau^{ac}_{ij} \tau^{ab}_{mn}u^{mn}_{cd} 
            + \frac{1}{2} \tau^{cd}_{ij}u^{ab}_{cd}
            + \frac{1}{2} \tau^{cd}_{jm} \tau^{ab}_{in} u^{mn}_{cd}P(ij) \\
            &\ - \frac{1}{2} \tau^{ac}_{nm} \tau^{bd}_{ij} u^{nm}_{cd}P(ab)
            + \tau^{ac}_{im} \tau^{bd}_{jn}u^{mn}_{cd}P(ij)
            + \tau^{ac}_{im}u^{bm}_{jc}P(ab)P(ij)
            + \frac{1}{2} \tau^{ab}_{mn}u^{mn}_{ij}.
        \end{aligned}
    \end{equation}

    \input{implementation/doc/ccd.tex}
   
    THIS IS NOT CORRECT WHEN INCLUDING LAMBDA..
    The initial guess in equation \autoref{eq:ccd_inital_guess} is terms 2 and 3
    from \autoref{eq:ccd_tau}. These terms also form the basis of the iterative scheme,
    if we move them to the left of the equal sign in \autoref{eq:ccd_tau}, 
    \begin{equation}
        D^{ab}_{ij} \tau^{ab}_{ij} = g(u, \tau),
    \end{equation}
    where $g(u, \tau)$ now consists of the rest of the doubles amplitude equation, our 
    recursion relation can be written
    \begin{equation}
        t^{(k+1)} = \frac{g(u,\tau^{(k)})}{D^{ab}_{ij}}.
    \end{equation}
    
    An example of a computation of one term from \autoref{eq:ccd_tau} is,
    \begin{python}
    def add_d2e_t(u, t, o, v, out, np):
        term = np.tensordot(t, u[o, v, v, o], axes=((1, 3), (2, 0))).transpose(
            0, 2, 1, 3
        )
        term -= term.swapaxes(0, 1)
        term -= term.swapaxes(2, 3)
        out += term
    \end{python}
    This function particular computes the $D_{2e}$ diagram\footnote{After the labelling from 
    \autoref{ch:coupled_cluster_theory} and Shavitt \& Bartlett\cite{shavitt2009many}}.

    Most of the rest of the methods in the \lstinline{CoupledClusterDoubles} class are there 
    for the use of other methods, or for extracting observables. Moving to the next logical 
    coupled cluster solver scheme; the coupled cluster method with single- and double 
    excitations is now a matter of taking into account the extra computations needed in 
    this scheme, for each method in the abstract base clase \lstinline{CoupledCluster}. 
    There are indeed many more computations, but the code will structurally be the same. 
    The class specification for \lstinline{CoupledClusterSinglesDoubles} is therefore 
    given here without specification of the methods as they are excactly the same. For testing 
    purposes, the \lstinline{CoupledClusterSingelsDoubles} class have the possibility 
    to only include double excitation at construction.

    \input{implementation/doc/ccsd.tex}

    The algorithm applied when computing the ground state in the orbital-adaptive sphere 
    is the nonorthogonal orbital-optimised coupled cluster (NOCC) method, developed by 
    Myhre\cite{myhre2018demonstrating}. The NOCC scheme is shown to converge towards full
    configuration interaction. Since the \lstinline{OACCD} class is acutally applying 
    NOCC it can be perceived as a misnomer, but as of yet there exist no ground state 
    equivalent of the time-dependent 
    orbital-adaptive coupled cluster (OACC) method. Such a method is in development, and there
    is strong indication that NOCC would be equivalent to a OACC ground state solver. What is 
    more, NOCC does vary the orbitals as well as iterate over amplitude, and we have therefore 
    opted to call it OACC.

    \input{implementation/doc/oaccd.tex}

    Our implementation of the NOCC ground state solver is inderited from code written by Rolf Myhre and 
    adapted to our 
    framework. We supply a brief overview of the algorithm here. The starting point for the 
    NOCC model is the bivariational Lagrangian
    \begin{equation}
        \label{eq:nocc_lagrangian}
        \mathscr{L} = \mel*{\tilde{\Psi}}{\hat{H}}{\Psi} \\
            = \mel*{\tilde{\phi}}
                {
                (1 + \Lambda) e^{-\hat{T}}e^{-\kappa}\hat{H}e^{\kappa}e^{\hat{T}}
                }{\phi}
    \end{equation}
    which is very similar to the coupled cluster Lagrangian (\autoref{eq:cc_energy_lagrangian}),
    except for a biorthogonal basis and a transformation of the Hamiltonian, defined 
    as follows
    \begin{equation}
        \begin{aligned}
            \tilde{c}_p^\dagger &= e^{-\kappa}\hat{c}_p^\dagger e^\kappa \\
            c_p &= e^{-\kappa} \hat{c}_p^\dagger e^\kappa \\
            \ket{\phi} &= e^{-\kappa}\ket*{\hat{\phi}}
        \end{aligned}
    \end{equation}
    where the orthogonal reference creation- and annihilation operators marked with a hat
    ($\hat{\ }$), as is the reference state function. We require that $\kappa$ is antihermitian,
    \begin{equation}
        \kappa = \sum_{pq} \kappa_{pq}c^\dagger_p c_q, \quad \kappa^\dagger = -\kappa.
    \end{equation}
    Moreover, we split $\kappa$ into excitations and relaxations (up and down),
    \begin{equation}
        \label{eq:agg_kappa}
        \kappa = \sum_{ai} \kappa^u_{ai}c^\dagger_a \tilde{a}_i
            + \kappa^d_{ia} c^\dagger_i \tilde{c}_a
            = \sum_{ai} \kappa^u_{ai} X_ai + \kappa^d_{ia} \tilde{X}^\dagger_{ia}.
    \end{equation} 
    
    As in any many-body formulation that includes a Lagrangian, we would like to compute 
    the first-order conditions of the Lagrangian, in order to derive what would be the 
    NOCC equation. The problem with this is that the result would be some extremely 
    lengthy expressions, because $\kappa$ does not commute with $\hat{T}$ or $\Lambda$.
    Therefore, we express the NOCC equations with an optimized basis where $\kappa=0$,
    where a solution would correspond to a stationary point of the SchrÃ¶dinger equation.
    This is the same as expanding the exponentials in $\kappa$ and keeping only zero-order 
    terms. This trick leads to an algorithm which iterates between orbital transformations 
    and amplitudes until self-consistency.

    At a particular stationary point the differential of the Lagrangian
    (\autoref{eq:nocc_lagrangian}) must be zero with respect to the four sets of 
    parameters $\{\tau\}$, $\{\lambda\}$, $\{\kappa^u\}$ and $\{\kappa^d\}$, giving
    us four sets of equations,
    \begin{align}
        \frac{\partial \mathscr{L}}{\partial \lambda_{\mu_n}}
            &= \mel*{\tilde{\phi}}
            {\tilde{X}_{\mu_n} e^{-\hat{T}}\hat{H}e^{\hat{T}}}
            {\phi}, \\
        \frac{\partial \mathscr{L}}{\partial \tau_{\mu_n}}
            &= \mel*{\tilde{\phi}}
            {(1 + \Lambda)e^{-\hat{T}}[\hat{H}, X_{\mu_n}]e^{\hat{T}}}
            {\phi}, \\
        \frac{\partial \mathscr{L}}{\partial \kappa^u_{\mu_1}}
            &= \mel*{\tilde{\phi}}
            {(1 + \Lambda)e^{-\hat{T}}[\hat{H}, X_{\mu_1}]e^{\hat{T}}}
            {\phi}, \\
        \frac{\partial \mathscr{L}}{\partial \kappa^d_{\mu_1}}
            &= \mel*{\tilde{\phi}}
            {(1 + \Lambda)e^{-\hat{T}}[\hat{H}, \tilde{X}_{\mu_1}]e^{\hat{T}}}
            {\phi}.
    \end{align}

    We are now ready to outline the full algorithm of the 
    \lstinline{compute\_ground\_state()} in what we have called the \lstinline{OACCD}.
    The method is iterating over the the norm of $\kappa^u$ and $\kappa^d$, called the 
    residuals of $\kappa$, until consistency compared to a tolerance value us achieved. 
    For each such iteration, iteration over the $\tau$ and $\lambda$ double excitation
    amplitudes is performed, but at a much less strict tolarance value than under the 
    \lstinline{CoupledClusterDoubles} scheme. After the iteration over $\tau$ and $\lambda$ 
    is achieved, the values for $\kappa^u$ and $\kappa^d$ are recalculated, in order to 
    compute the aggragate $\kappa$ (\autoref{eq:agg_kappa}), 
    which in turn can be used to transform the orbitals,
    \begin{equation*}
        \begin{gathered}
            h^{(k + 1)} = e^{-\kappa} h^{(k)} e^{\kappa}, \\
            (u^{pq}_{rs})^{(k + 1)}
            = (e^{-\kappa})^p_a (e^{-\kappa})^q_b 
                (u^{ab}_{cd})^{(k)}
            (e^{\kappa})^d_s (e^{\kappa})^c_r,
        \end{gathered}
    \end{equation*}
    which (in addition to being written with incomprehensible notation) is used to compute 
    a new Fock operator. The resulting rotation of the orbitals will aid in better 
    convergence towards the ground state. FLOW CHART??
    
\subsection{Mixing}


    \input{implementation/doc/mixer_alpha.tex}

    \input{implementation/doc/diis.tex}

\section{[UNFINISHED] Time Development}

    \input{implementation/doc/tdcc.tex}

    \input{implementation/doc/tdccsd.tex}

    \input{implementation/doc/oatdccd.tex}

\subsection{Integrators and ODE Solvers}

    \input{implementation/doc/integrator.tex}

    \input{implementation/doc/RK4.tex}

    \input{implementation/doc/gauss_integrator.tex}